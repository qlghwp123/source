1장
표준 헤더파일의 선언에서는 확장자를 생략하기로 약속
    과거 표준 입출력 라이브러리는 .h
    새로운 표준 입출력 라이브러리는 생략
std::cout << '출력대상' 에서 출력대상에는 무엇이든 올 수 있다.
<<도 사실 연산자이며 둘 이상의 출력 대상을 연이어서 출력할 수 있다.
<<연산자를 이용한 std::endl의 출력은 개행으로 이어진다.
변수의 선언은 어디에서든 가능하다.
C++에서는 데이터의 입력도 데이터 출력과 마찬가지로 별도의 포맷 지정이 필요 없다.
std::cin >> 변수1 >> 변수 2 에서 데이터 간 경계는 탭, 스페이스 바, 엔터 키 입력과 같은 공백에 의해 나눠진다.
함수 오버로딩은 함수이름과 함수 매개변수를 따진다.
매개변수 디폴트 값에서 인자는 왼쪽에서 채워나가고 부족분은 디폴트 값으로 채워진다.
매개변수 디폴트 값 지정은 선언부분에만 위치시켜야 한다.
함수 정의 시 디폴트 값은 반드시 오른쪽부터 채워져야한다.(이유는 전달인자는 왼쪽부터 오른쪽까지 채워지기 때문이다.)
함수 몸체부분이 함수호출 문장을 완전히 대체했을 때 '함수가 인라인화 되었다.' 라고 한다. 즉 매크로 함수의 장점은 유지하고 단점은 제거한 것이 바로 인라인 함수이다.
매크로를 이용한 함수의 인라인화는 전처리기에 의해서 처리되고 키워드 inline을 이용한 함수의 인라인화는 컴파일러에 의해서 처리가 된다. 따라서 컴파일러가 인라인화가 성능에 해가 된다면 컴파일러가 무시하기도 한다. 또한 컴파일러는 필요한 경우 일부 함수를 임의로 인라인 처리하기도 한다.
사실 인라인이 매크로를 완전히 대체하지 못했다. 반환형이 정해져있으므로 여러 반환형을 해야할 경우 함수 오버로딩을 하여 여러 함수를 작성해야 하는 (자료형에 의지하는) 단점이 있으나 이는 템플릿이라는 문법을 사용하면 된다.
:: 를 범위지정 연산자라 한다.
동일한 이름공간에 정의된 함수를 호출할 때에는 이름공간 명시를 할 필요 없다.
이름공간에 별칭을 줄 수 있다.
이름이 같은 전역변수에 접근할 때는 '::이름' 을 쓰면 된다. 즉 이름 앞에 범위지정 연산자를 붙여주면 가능하다.

2장
true와 false는 1과 0 이 아니며 참과 거짓을 표현하기 위한 1바이트 크기 데이터일 뿐이다. 이 둘을 출력하거나 정수 형태로 형 변환 시 각각 1, 0 으로 변환되도록 정의되어 있을 뿐이다.
참조자는 자신이 참조하는 변수를 대신할 수 있는 또 하나의 이름이다. 
참조자는 변수와 달리 변수를 대상으로만 선언이 가능하다.
함수 내 지역적 참조자는 함수를 벗어나면 소멸된다.
전통적으로 C++ 에서는 참조자를 "변수에 별칭을 하나 붙여주는 것이다" 라고 설명한다.
참조자의 수에 제한은 없으며, 참조자를 대상으로 참조자를 선언할 수 있다.
상수를 대상으로 참조자 선언이 불가능, 미리 참조자를 선언했다가 후에 참조하는 것도 불가능, 참조 대상 바꾸는 것도 불가능.
참조자를 NULL로 초기화하는 것도 불가능.
참조자는 반드시 선언과 동시에 변수를 참조해야 한다.(변수의 범위는 배열 요소도 포함)
포인터 변수도 변수이기에 참조자 선언이 가능하다. 다음과 같이 선언할 수 있다.
    TYPE *(&참조자) = 포인터
Call-By-Reference : 주소 값이 외부 변수의 참조 도구로 사용되는 함수 호출
C++에는 2가지 Call-By-Reference가 존재한다.
    주소 값을 이용한 Call-By-Reference
    참조자를 이용한 Call-By-Reference
매개변수는 함수가 호출되어야 초기화가 진행되는 변수이다. 그래서 매개변수에 참조자가 오는 선언은 함수호출 시 전달되는 인자로 초기화를 하겠다는 의미의 선언이다.
코드 분석을 할 때, 참조자를 쓰는 곳이 있으면 함수 호출문장만 보고는 함수의 특성을 파악하기가 힘들다. 함수 원형도 확인해야 하고 매개변수에 참조자가 있다면 값을 변경시키는지 확인까지 해야하기 때문이다. 따라서 매개변수에 참조자가 와있다면 변경시키지 않는 함수일 경우 참조자에 const 키워드를 사용하여 명백히 하는 것이 좋다.
함수의 지역변수를 참조자로 반환하는 경우는 컴파일러가 에러를 띄워주지 않는다.
상수화된 변수를 참조하는 법
    const int num = 10;
    const int &ref = num;
위와 같이 참조자 자료형 앞에 const 키워드를 붙이면 된다.
리터럴 상수 : 임시적으로 존재하는 값이다. 다음 행으로 넘어가면 존재하지 않는 상수이다.
const int &ref = 30 이 문장이 성립할 수 있도록 C++에서는 const 참조자를 이용해서 상수를 참조할 때, '임시변수'라는 것을 만들어서 이 장소에 30을 저장하고 참조자가 이를 참조하게끔 한다.
const TYPE 변수1 의 주소값을 포인터에 저장할 때에 상수값이므로 const TYPE *포인터변수1 와 같이 포인터 변수에도 const를 붙여야한다. 참조자도 마찬가지이다.
delete []변수이름
new 연산자를 이용해서 할당된 메모리 공간도 변수로 간주한다. 따라서 참조자의 선언이 가능하다.
    int *ptr = new int;
    int &ref = *ptr;
    ref = 20;
    cout << *ptr << endl;

3장
별도의 typedef 없이도 다음과 같이 변수를 선언할 수 있다.
    Car basicCar
    Car simpleCar
C++에서 구조체 안에 함수를 삽입하는 것을 허용한다.
C++에서 모든 구조체 변수는 하나의 함수를 공유한다. 즉 변수 선언할 때마다 각자 따로 가지고 있는 것처럼 보여도 실제로는 하나만 가지고 그것을 공유한다.
열거형을 구조체 안에 넣을 수 있다.
구조체에서 함수를 밖으로 뺄 때, 선언은 구조체 안에 해두고 정의는 밖에 해둘 수 있다.
구조체 안에 함수가 '정의'되어 있으면, 함수를 인라인으로 처리하라는 의미를 포함한다.
C++의 구조체는 클래스의 일종이다.
클래스는 기본적으로 클래스 내에 선언된 변수는 클래스 내에 선언된 함수에서만 접근 가능하다.
별도의 접근제어 지시자를 사용하지 않는다면 
    struct를 사용하여 정의된 구조체 내 모든 변수와 함수는 public
    class 를 사용하여 정의된 클래스 내 모든 변수와 함수는 private
접근제어 지시자 뒤에 콜론이 붙는 이유는 접근제어 지시자가 위치정보를 알리는 '레이블(라벨)' 이기 때문이다.
인라인 함수는 컴파일 과정에서 함수의 호출문이 있는 곳에 함수의 몸체 부분이 삽입되어야 한다.
객체는 하나 이상의 상태 정보(데이터)와 하나 이상의 행동(기능)으로 구성이 되어있다.
클래스 선언문에서 초기화를 하는 것을 허용하지 않는다.
객체를 실체화시키는 방법은 다음과 같다.
    ClassName ObjName;
    ClassName *ptrObj = new ClassName; <- 이부분은 동적 할당 방식이다.
한 객체가 다른 하나의 객체에게 메시지를 전달하기 위해서 함수호출을 하는 것을 메시지 전달이라 한다.

4장
좋은 클래스를 만드는 최소한의 기본 조건은 정보 은닉과 캡슐화이다.
정보 은닉은 
    1. 멤버 변수를 private로 선언한다.
    2. 멤버 변수에 접근하는 함수를 따로 만든다.(이를 Access 함수라고 한다.)
함수 뒤에 const 선언을 하면 그 함수 내에서 멤버변수의 값을 바꿀 수 없다. 바꾸면 컴파일 에러가 난다.
const 함수에서 const가 아닌 함수를 호출할 수 없다. 호출 시 컴파일 에러가 발생한다.
C++에서 const 참조자를 대상으로 값의 변경 능력을 가진 함수의 호출을 허용하지 않는다.
캡슐화는 감싸는 개념이며, 어려운 개념이다 보니 캡슐화의 범위를 설정하는 것이 쉽지 않다.
생성자는
    클래스 이름과 함수 이름이 동일하다.
    반환형이 선언되지 않았으며 실제로 반환하지 않는다.
    객체 생성 시 딱 한번 초기화 된다.
    함수의 일종이니 오버로딩이 가능하다.
    함수의 일종이니 매개변수에 디폴트 값을 설정할 수 있다.
함수 원형은 보통 함수 밖에 선언하지만, 함수 내에 지역적으로도 선언이 가능하다.
ClassName 객체이름() 
    이 문장을 생성자의 호출문으로 인정해버리면 컴파일러는 이것이 객체생성, 함수 원형 선언 구분을 못한다. 그래서 이 문장을 함수 원형 선언에만 사용하기로 약속하였다.
멤버 이니셜라이저 : 한 객체 멤버변수가 객체일 경우 사용되는 것
    멤버변수의 생성자를 통해서 변수를 초기화할 때 사용되는 것이 멤버 이니셜라이저이다.
객체 생성과정
    1. 메모리 공간의 할당
    2. 이니셜라이저를 이용한 멤버변수(객체)의 초기화
    3. 생성자의 몸체부분 실행
생성자는 반드시 호출된다.(없으면 디폴트 생성자가 자동삽입되어 호출)
객체가 아닌 멤버변수도 이니셜라이저를 통해서 초기화 가능
이니셜라이저의 이점
    1. 초기화의 대상을 명확히 할 수 있다.
    2. 성능에 약간의 이점이 있다. -> 선언과 동시에 초기화가 이뤄지는 형태로 바이너리 코드가 생성되기 때문이다.
const 멤버변수도 이니셜라이저를 이용하면 초기화가 가능하다.
객체가 되기 위해서는 반드시 하나의 생성자가 호출되어야 한다.
모든 객체는 한번의 생성자 호출을 동반한다.(new연산자를 이용한 객체의 생성에도 해당하는 이야기)이 때, new 대신 C언어의 malloc을 사용하면 생성자는 호출되지 않는다.
클래스 내부에서만 객체의 생성을 허용하려는 목적으로 생성자를 private로 선언하기도 한다.
private 생성자는 객체의 생성방법을 제한하고자 하는 경우에 매우 유용하게 사용된다.
객체 소멸 시 반드시 호출되는 것은 소멸자이다.
    1. 클래스의 이름 앞에 '~'가 붙은 형태의 이름을 갖는다.
    2. 반환형이 선언되어 있지 않으며, 실제로 반환되지 않는다.
    3. 매개변수는 void 형으로 선언되어야 하기 때문에 오버로딩도, 디폴트 값 설정도 불가능하다.
    4. 생성자와 마찬가지로 프로그래머가 직접 소멸자를 정의하지 않으면, 디폴트 생성자와 마찬가지로 디폴트 소멸자가 자동으로 삽입된다.
객체를 저장할 때
    1. 객체로 저장
    2. 객체의 주소 값으로 저장
중 선택을 해야한다.
멤버함수 내에서 this 라는 이름의 포인터를 사용할 수 있다. 이는 객체 자신을 가리키는 용도로 사용되는 포인터이다.
Self-Reference : 객체 자신을 참조할 수 있는 참조자를 의미한다.

5장
초기화 방법
    1. int num = 20
    2. int num(20)
객체 생성 중 1번과 같은 문장이 있을 때, 2번 문장과 같이 묵시적으로 변환된다.
    1. 클래스이름 변수1 = 변수2
    2. 클래스이름 변수1(변수2)
복사생성자는 다음과 같다.
    SoSimple(SoSimple &copy) : num1(copy.num1), num2(copy.num2) {}
    일반 생성자와 다른 점은 호출되는 시점이 다르다.
복사 생성자를 정의하지 않으면, 멤버 대 멤버 복사를 진행하는 디폴트 복사 생성자가 자동으로 삽입된다.
복사 생성자의 묵시적 호출을 허용을 원하지 않는다면 복사 생성자에 explicit 을 추가하면 된다.
만약 전달인자가 하나인 생성자가 있다면 이 역시 복사 생성자의 묵시적 호출이 일어난다. 이 또한 묵시적 호출을 원하지 않는다면 그 복사 생성자 앞에 explicit을 추가하면 된다.
디폴트 복사 생성자는 멤버 대 멤버 복사를 진행한다. 이를 얕은 복사라 한다.
복사 생성자가 호출되는 시점
    1. 새로운 객체를 초기화할 때, 기존의 객체를 이용하는 경우
    2. Call-By-Value 방식의 함수호출 과정에서 객체를 인자로 전달하는 경우
    3. 객체를 반환하되, 참조형으로 반환하지 않는 경우
값을 반환하면 반환된 값은 별도의 메모리 공간이 할당되어서 저장이 된다.
클래스 외부에서 객체의 멤버함수를 호출하기 위해 필요한 것은 다음 세 가지 중 하나이다.
    1. 객체에 붙여진 이름
    2. 객체의 참조 값
    3. 객체의 주소 값
임시객체
    1. 다음 행으로 넘어가면 바로 소멸되어 버린다.
    2. 참조자에 참조되는 임시객체는 바로 소멸되지 않는다.

6장
다음과 같이 객체도 상수화 할 수 있다.
    const SoSimple sim(20);
    이렇게 객체에 const 선언이 붙게되면 이 객체를 대상으로는 const 멤버함수만 호출 가능하다.
함수 오버로딩 조건은 매개변수 개수와 자료형에 이였다. 하지만 const 선언유무도 오버로딩 조건에 해당된다.
friend 선언은 다음과 같다.
    1. A 클래스가 B 클래스 대상으로 friend 선언을 하면, B 클래스는 A 클래스의 private 멤버에 직접 접근이 가능하다.
    2. A 클래스도 B 클래스에 private 멤버에 접근하려면, B 클래스도 A 클래스 대상으로 friend 선언을 해줘야 한다.
friend 선언은 클래스 내에 어디든 위치할 수 있다.
friend 선언은 전역함수, 클래스의 멤버함수 대상으로도 가능하다.
static 멤버변수는
    클래스 변수라고도 한다. 
    클래스당 하나씩만 생성된다.
    객체를 생성하건 생성하지 않건 메모리 공간에 딱 하나만 할당된다.
    여러 객체가 있으면 static 멤버변수를 공유한다.
    객체 내에 존재하는 것이 아니라 객체 외부에 있다.
    생성 및 소멸 시점도 전역변수와 동일하다.
    초기화 문법이 별도로 정의되어 있다.
        int SoSimple::simObjCnt = 0;
static 멤버함수도 static 멤버변수와 동일하다.
    선언된 클래스의 모든 객체가 공유한다.
    public 으로 선언되면 클래스의 이름을 이용해서 호출이 가능하다.
    객체의 멤버로 존재하는 것이 아니다 -> 전역변수와 생성 시점이 동일하다.
    static 멤버함수 내에서는 static 멤버변수, static 멤버함수만 호출 가능하다.
const static 멤버
    클래스가 정의될 때 지정된 값이 유지되는 상수이다.
    초기화 방법은
    public:
        const static int RUSSIA = 17017540;
mutable
    이 키워드가 붙은 멤버변수는 const 함수 내에서 값 변경을 예외적으로 허용한다는 의미이다.

7장
컨트롤 클래스(=핸들러 클래스)
    기능의 처리를 실제로 담당하는 클래스
    기능 제공의 핵심이 되기 때문에 모든 객체지향 프로그램에서 반드시 존재한다.
A가 B를 상속한다.
    A 클래스는 B 클래스가 지니고 있는 모든 멤버를 물려받는다.
    A 클래스의 생성자는 B 클래스 멤버까지 초기화할 의무가 있다.
    A 클래스의 생성자에서 B 클래스 멤버를 초기화 하기 위해서 B 클래스 생성자를 호출하는게 좋다.
멤버의 접근제한 기준은 객체가 아닌 클래스이다.
정보 은닉은 하나의 객체 내에서도 진행이 된다. -> 상속했더라도 public에 정의된 함수를 통하여 간접적으로 접근해야함.
상속 용어 정리
    상위 클래스 <-> 하위 클래스
    기초(base) 클래스 <-> 유도(derived)클래스
    슈퍼(super) 클래스 <-> 서브(sub) 클래스
    부모 클래스 <-> 자식 클래스
유도 클래스의 객체생성 과정에서 기초 클래스의 생성자는 100% 호출된다.
유도 클래스의 생성자에서 기초 클래스의 생성자 호출을 명시하지 않으면, 기초 클래스의 void 생성자가 호출된다.
유도 클래스의 객체 생성과정에서도 "클래스의 멤버는 해당 클래스의 생성자를 통해서 초기화해야 한다." 가 지켜져야 한다.
유도 클래스의 객체가 소멸될 때에는 유도 클래스의 소멸자가 생성되고 난 다음에 기초 클래스의 소멸자가 실행된다. 그리고 이러한 특성 때문에 상속과 연관된 클래스는 "생성자에서 동적 할당한 메모리 공간은 소멸자에서 해제한다" 라는 원칙을 지켜서 정의해야 한다. 
3가지 상속
    private 상속 : private 보다 접근 범위가 넓은 멤버는 private 로 변경시켜서 상속하겠다.
    protected 상속 : protected 보다 접근 범위가 넓은 멤버는 protected 로 변경시켜서 상속하겠다.
    public 상속 : public 보다 접근 범위가 넓은 멤버는 public으로 변경시켜서 상속하겠다. -> private을 제외한 나머지는 그냥 그대로 상속한다.
엔티티 클래스 : 컨트롤 클래스가 아닌 대부분의 클래스
    데이터적 성격이 강하다. 따라서 파일 및 데이터 베이스에 저장되는 데이터를 소유하고 있다.
    프로그램의 기능을 파악하는데 도움을 주지는 못한다.
    그러나 프로그램상에서 관리되는 데이터의 종류를 파악하는 데는 도움이 된다.

8장
C++ 에서, AAA형 포인터 변수는 AAA객체 또는 AAA를 직접 혹은 간접적으로 상속하는 모든 객체를 가리킬 수 있다.(객체의 주소 값을 저장할 수 있다.)
함수 오버라이딩
    유도 클래스에서 기초 클래스에 있는 함수를 재정의하는 것.(여기서 매개변수 개수와 매개변수 자료형이 다르면 함수 오버로딩으로 간주.)
가상함수
    C++ 컴파일러는 포인터 연산의 가능성 여부를 판단할 때, 포인터의 자료형을 기준으로 판단하지, 실제 가리키는 객체의 자료형을 기준으로 판단하지 않는다.
    어떤 함수를 가상함수로 선언하고 나면 이 함수를 오버라이딩 하는 함수도 가상함수가 된다.
    함수가 가상함수로 선언되면, 포인터 변수가 실제로 가리키는 객체를 참조하여 호출의 대상을 결정하게 된다.
순수 가상함수
    함수 몸체가 정의되지 않은 함수를 의미한다.
    장점
        1. 잘못된 객체 생성을 막을 수 있다.
        2. 실제로 실행이 되는 함수가 아님을 명시할 수 있다.
    사용법
        virtual 반환형 함수이름() const = 0
추상 클래스
    하나 이상의 순수 가상함수를 가지는 클래스
가상 소멸자
    객체의 소멸 과정에서는 delete 연산자에 사용된 포인터 변수의 자료형에 상관없이 모든 소멸자가 호출되어야 하는데 이때 사용된다.
    소멸자도 가상함수와 마찬가지로 상속 계층 구조 상 맨 위에 존재하는 기초 클래스의 소멸자만 virtual 로 선언하면 이를 상속하는 유도 클래스의 소멸자들도 모두 가상 소멸자로 선언이 된다.
    가상 소멸자가 호출되면, 상속 계층 구조 상 맨 아래에 존재하는 유도 클래스의 소멸자가 대신 호출되고 기초 클래스의 소멸자가 순차적으로 호출된다.
참조자
    C++에서, AAA형 참조자는 AAA객체 또는 AAA를 직접 혹은 간접적으로 상속하는 모든 객체를 참조할 수 있다.

9장
객체의 멤버함수
    객체가 생성되면 멤버함수는 메모리의 한 공간에 별도로 위치하고선, 이 함수가 정의된 클래스의 모든 객체가 이를 공유한다.
가상함수 원리
    오버라이딩 된 가상함수의 주소정보는 유도 클래스의 가상함수 테이블에 포함되지 않는다. 때문에 오버라이딩 된 가상함수를 호출하면, 무조건 가장 마지막에 오버라이딩을 한 유도 클래스의 멤버함수가 호출되는 것이다.
가상함수 테이블은 객체의 생성과 상관없이 메모리 공간에 할당된다.
가상함수를 하나이상 멤버로 지니는 클래스의 객체에는 가상함수 테이블의 주소 값이 저장된다. 사용자가 직접 참조할 수는 없다.
콤마(쉼표)를 이용해서 상속의 대상이 되는 클래스를 구분할 수 있고, 또 상속하는 형태는 각각 별도로 지정이 가능하다.
다중 상속으로 인하여 클래스의 멤버를 2개씩 가지게 되는 경우, 가상 상속을 이용하면 1개씩만 존재하게 된다.

10장
연산자 오버로딩 방법 2가지
    멤버함수에 의한 연산자 오버로딩
        객체 pos1, pos2가 있다면 pos1 + pos2 는 pos1.operator+(pos2) 와 100% 동일하다.
        멤버함수 기반으로 오버로딩 된 함수가 전역함수 기반으로 오버로딩 된 함수보다 우선시되어 호출된다.
        멤버함수 기반으로만 오버로딩 할 수 있는 연산자들
            = 대입 연산자
            () 함수 호출 연산자
            [] 배열 접근 연산자(인덱스 연산자)
            -> 멤버 접근을 위한 포인터 연산자
연산자 오버로딩 시 주의사항
    1. 본래의 의도를 벗어난 형태의 연산자 오버로딩은 좋지 않다.
    2. 연산자의 우선순위와 결합성은 바뀌지 않는다.
    3. 매개변수의 디폴트 값 설정이 불가능하다.
    4. 연산자의 순수 기능까지 빼앗을 수 없다.
전위/후위 연산에 대한 해석 방식
    ++pos -> pos.operator++()
    pos++ -> pos.operator++(int)
    이 때, 여기서 int 는 int가 지닌 의미와는 아무 상관이 없다.
반환형에 const 가 붙은 함수는 반환할 때 생기는 임시객체를 const 객체로 선언하겠다는 의미이다. 
const 객체 대상으로 참조자 선언 시 참조자도 반드시 const 선언 해야한다.

11장
대입 연산자의 대표적인 특성 3가지
    1. 정의하지 않으면 디폴트 대입 연산자가 삽입된다.
    2. 디폴트 대입 연산자는 멤버 대 멤버의(얕은 복사)를 진행한다.
    3. 연산자 내에서 동적 할당을 한다면, 그리고 깊은 복사가 필요하다면 직접 정의해야 한다.
생성자 내에서 동적 할당을 하는 경우 발생하는 2가지 문제점
    1. 깊은 복사를 진행하도록 정의한다.
    2. 메모리 누수가 발생하지 않도록, 깊은 복사에 앞서 메모리 해제의 과정을 거친다.
유도 클래스의 대입 연산자에는 아무런 명시를 하지 않으면, 기초 클래스의 대입 연산자가 호출되지 않는다.
유도 클래스의 대입 연산자 정의에서, 명시적으로 기초 클래스의 대입 연산자 호출문을 삽입하지 않으면, 기초 클래스의 대입 연산자는 호출되지 않아서, 기초 클래스의 멤버변수는 멤버 대 멤버의 복사 대상에서 제외된다.
4장에서 언급했던 내용 : 
    1. 이니셜라이저를 이용하면 선언과 동시에 초기화가 이뤄지는 형태로 바이너리 코드가 생성된다. 
    2. 생성자의 몸체부분에서 대입연산을 통한 초기화를 진행하면, 선언과 초기화를 각각 별도의 문장에서 진행하는 형태로 바이너리 코드가 생성된다.
    3. 위를 인지하고 이니셜라이저를 사용하면 함수의 호출횟수를 줄일 수 있어서, 그리고 초기화의 과정을 단순화시킬 수 있어서 약간의 성능향상을 기대할 수 있다.
배열은 저장소의 일종, 저장소에 저장된 데이터는 '유일성' 이 보장되어야 하기 때문에, 대부분의 경우 저장소의 복사는 불필요하거나 잘못된 일로 간주된다. 그래서 빈 상태로 정의된 복사 생성자와 대입 연산자를 private 멤버로 두어 원천적으로 막는 것이 좋은 선택이 되기도 한다.
기본적으로 제공되는 new 연산자의 기능
    1. 메모리 공간의 할당
    2. 생성자의 호출
    3. 할당하고자 하는 자료형에 맞게 반환된 주소 값의 형 변환
new 연산자는 기본적으로 제공되는 기능 중 첫 번째 기능만 오버로딩 가능하다. 나머지 2개의 기능은 컴파알리에 의해 진행되며, 할 수 있는 대상도 아니다.
new 연산자 오버로딩
    1. new 연산자 오버로딩은 void * operator new(size_t size) { ... } 로 오버로딩 하도록 약속되어 있다.
    2. 이렇게 오버로딩된 함수는 컴파일러에 의해서 호출된다.
    3. 크기 정보는 바이트 단위로 계산되어 전달된다.
new 연산자가 반환되는 값은 operator new 함수가 반환하는 값이 아니다.
operator new 함수가 반환하는 값은 컴파일러에 의해 적절히 형 변환이 된 값이다.
다음과 같이 어떤 한 객체의 소멸을 명령하면
    Point *ptr = new Point(3,4);
    delete ptr;
    컴파일러는 먼저 ptr이 가리키는 객체의 소멸자를 호출한다.
    그리고 void operator delete(void *adr) { ... } 함수에 ptr에 저장된 주소 값을 전달한다.
    즉, 소멸자는 오버로딩 된 함수가 호출되기 전에 호출이 되니 오버로딩 된 함수에서는 메모리 공간의 소멸을 책임져야 한다.
사실 operator new, operator delete 함수는 멤버함수 형태로 선언을 해도 static 함수로 간주가 된다. 
new[] 연산자 오버로딩
    Point *arr = new Point[3] 과 같은 문장을 만나면
    1. 컴파일러는 세 개의 Point 객체에 필요한 메모리 공간을 바이트 단위로 계산한다.
    2. 위에서 계산한 값을 인자로 void *operator new[](size_t size) 함수에 전달한다.
delete[] 연산자 오버로딩
    delete []arr 같은 문장을 만나면
    1. 컴파일러는 소멸자를 호출한다.
    2. 그런 다음 arr 에 저장된 주소 값을 void operator delete[](size_t size) 함수에 인자로 전달한다.
포인터를 기반으로 하는 연산을 포인터 연산자라 한다.
대표적인 포인터 연산자는 다음과 같다.
    1. -> : 포인터가 가리키는 객체의 멤버에 접근
    2. * : 포인터가 가리키는 객체에 접근
->, * 연산자 모두 피연산자가 하나인 단항 연산자의 형태로 오버로딩 된다.
객체->함수() 에서
    일반적인 해석이라면 객체.operator->() 함수() 가 된다.
    그런데 이는 함수 호출에 있어 적절하지 못한 표현이 된다. 왜냐면 객체.operator->() 는 결국 주소값을 반환하기에 "주소값 함수()" 가 되어버린다. 즉 주소값과 함수() 사이에 -> 필요하다.
    따라서 반환되는 주소 값을 대상으로 적절한 연산이 되도록 -> 연산자를 하나 더 추가하여 다음과 같이 해석을 진행한다.
    객체.operator->() -> 함수()
스마트 포인터는 
    1. 객체로, 포인터의 역할을 하는 객체를 의미한다.
    2. 스마트포인터의 가장 기본은 operator*,-> 이다.
    3. 어떤 한 객체를 대상으로 하는 스마트 포인터는 해당 객체의 소멸을 위한 delete 연산이 자동으로 이뤄진다.
    4. 대부분 라이브러리에 구현되어 있다.
()연산자 오버로딩
    이 연산자를 오버로딩 하면, 객체를 함수처럼 사용할 수 있다.
    원형은 객체.operator()( ... ) 이다.
함수처럼 동작하는 클래스를 가리켜 '펑터(Functor)' 그리고 '함수 오브젝트(Function object)' 라고도 불린다.
return문에서도 임시객체를 생성과 동시에 반환하는 것이 가능하다.
함수호출문에서도 임시객체를 생성하는 것이 가능하다.
펑터는 함수 또는 객체의 동작방식에 유연함을 제공할 때 사용된다. 자세한건 11-16(SoftFunctor.cpp)
A형 객체가 와야 할 위치에 B형 데이터(또는 객체)가 왔을 경우, B형 데이터를 인자로 전달받는 A형 클래스의 생성자 호출을 통해서 A형 임시객체를 생성한다.
형 변환 연산자
    operator 자료형 ()
    {
        return 멤버변수
    }
    형 변환 연산자는 반환형을 명시하지 않는다. 하지만 return 문에 의한 값의 반환은 가능하다.
