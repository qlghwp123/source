2장
C언어로 프로그램을 작성 : 함수를 만들고 함수들의 실행순서를 정하는 것.
즉, 정해진 순서에 의해서 진행되는 함수의 호출이 바로 프로그램의 흐름이 된다.

3장
값을 저장할 수 있는 메모리 공간 이름 혹은 그 공간을 가리켜 변수라 한다.
후위 연산자는 소괄호의 영향을 받지 않고 다음 문장으로 넘어가야만 비로소 값의 증가 및 감소가 이뤄진다.
결합 방향 : 같은 우선순위의 연산자가 있을 때 어느 것 부터 하겠냐를 결정함.
scanf : 공백을 기준으로 데이터를 구분, gcc 에서는 엔터로 해도 적용됨
! : NOT연산으로 참이면 거짓, 거짓이면 참을 반환. 논리 연산자 중 하나임

4장
int num = 숫자(10진수)
	  0x으로 시작하면 16진수
	  0으로 시작하면 8진수
내부적으론 2진수의 형태로 값을 저장
정수를 표현하는데 있어서 가장 왼쪽에 존재하는 비트는 부호를 표현하는 MSB이다.
음수를 2의 보수로 취하는 이유는 정수와 그냥 단순히 MSB만 1로 바꾸고 더한 값이랑 더하면 0이 되어야하는데 실제로 그렇진 않다. 따라서 2의 보수를 취한다.
부동소수점 오차는 실수 표현에 대한 한계에 의하여 발생된다.
비트연산자 중 ~연산자는 단항 연산자로서 피연산자의 모든 비트를 반전시킨다.

5장
자료형은 데이터를 표현하는 방법이다.
ANSI에서 short int 는 최소 2바이트, short<=int 이어야한다. 정도로 자료형 별 크기를 정확하게 제한하지는 않는다. 그래서 컴파일러마다 다를 수 있다.
왜 자료형은 다양할까? 
	1. 정수, 실수와 같은 데이터 표현방식이 다르므로 최소 둘 이상의 자료형이 필요하다.
	2. 한 종류의 자료형 중에서도 크기가 다양한 자료형이 있는 이유는 메모리 공간을 효과적으로 사용하기 위함이다.
sizeof는 연산자이다.
일반적으로 CPU가 처리하기에 가장 적합한 크기의 정수 자료형을 int로 정의한다. 따라서 int형 자료형은 다른 정수 자료형보다 같거나 더 빠르다.
실수 자료형 선택에 있어서 가장 중요한 요소는 정밀도이다.
double형 입력은 %lf로 출력은 %f를 사용한다.
정수 자료형만 unsigned 가능하다.
char 자료형은 signed char 라고 signed 키워드를 붙이기도 한다. 이유는 어떤 컴파일러는 signed char 가 아닌 unsigned char으로 컴파일 하기 때문이다. 그래서 음수로 저장할 때는 선언 시 signed char 를 붙인다.
프로그램 상에서 문자표현은 작은따옴표로 표현된다.
정수는 숫자, 문자로 표현 가능하다.
아스키 코드 값이 0이상 127이하로 이뤄져 있는 것처럼 char 자료형은 문자 표현을 위해 정의된 자료형이다.
int가 더 빠른데 왜 문자 표현에 char를 쓸까?
	그 이유는 바로 "연산"에 있다. A에 곱하거나 덧셈을 할 일은 거의 없기 때문이다. (실제 변수에 저장되는건 숫자기에 사칙연산 가능)
메모리 상에 저장되는 모든 데이터는 자료형이 결정되어야 한다.
int 형으로 표현 가능한 정수형 상수는 int 형으로 메모리 공간에 저장하기로 약속, double 형으로 표현 가능한 실수형 상수는 double 형으로 메모리 공간에 저장하기로 약속되어있다.
문자형도 역시 컴파일러가 볼 때는 정수형이므로 int 형이다.
float a = 3.14 와 같은 경우에 실수형 상수 뒤 접미사 f를 붙여주면 된다. 그리고 대소문자 구분 안한다.
이름을 지니는 상수를 가리켜 심볼릭 상수라 한다. 심볼릭 상수를 만드는 const 키워드를 사용하는 방법과 매크로를 사용하는 방법이 있다. 이 경우 심볼릭 상수를 선언과 동시에 초기화를 해야한다.
자료형의 변환 => 데이터의 표현 방식을 바꾸는 것.
자동 형변환
	정수형 데이터 -> 실수형 데이터 : 데이터 손실 X, 실수형이다 보니 오차가 발생
	실수형 데이터 -> 정수형 데이터 : 소수부 손실
	큰 정수형 데이터 -> 작은 정수형 데이터 : 상위 바이트 손실
피연산자의 자료형이 일치하지 않아서 발생하는 자동 형변환은 데이터의 손실을 최소화하는 방향으로 진행된다.
int -> long -> long long -> float -> double -> long double
실수가 후순위인 이유는 "데이터 손실"을 최소화하는 것을 명심해야 한다. 실수->정수 는 반드시 소수부의 손실을 일으키는 반면 정수->실수 는 단지 소수부와 오차가 생길뿐 데이터 손실을 일으키지 않기 때문이다.

6장
printf : 서식이 지정된 형태의 출력 즉, 출력양식이 만들어진 상태에서 출력을 진행한다. 출력양식 즉 서식은 서식문자들을 이용하여 서식을 지정한다.
%g : 값에 따라서 %f, %e로 출력
%e : e표기법으로 값을 출력
실수의 입력과정에서 e 표기법을 사용해도 된다.
float, double, long double 의 데이터 출력에 사용되는 서식문자 각각 %f, %f, %Lf이며, float, double, long double 의 데이터 입력에 사용되는 서식문자는 각각 %f, %lf, %Lf이다.

7장
while(num++<times)				while(num++<times)
								{
									num++;
    printf("%d ", 3*num);  == 		printf("%d ", 3*num);
								}
반복 횟수가 정해져있다면 for문이 최선.

8장
if~else if~else 에서 하나라도 조건 만족되면 해당 블록 실행하고 나서 나머지들(else 포함) 바로 건너뜀.
실상 if~else if~else 는 if~else 문의 중첩이다. 건너뛰는 이유도 이러한 중첩 구조 때문이다.
break문을 가장 가까이서 감싸고 있는 반복문 하나를 빠져 나오게 된다. if문이 가장 가까이 감싸고 있어도 반복문을 빠져나오는 것이다.
continue문이 실행되면 가장 가까이서 감싸고 있는 반복문의 조건검사 부분으로 가게 된다.
case문의 영역을 label 이라한다. case 영역을 case 레이블이라고 함.
switch문의 default 도 생략가능하다.
goto문에서 가고자 하는 영역도 레이블이라고 한다.

9장
printf도 반환값이 있으며 그 반환값은 문자열의 길이를 반환한다.
함수에서 값이 반환된다는 것은 함수의 호출문이 반환 값으로 대체되는 것으로 이해할 수 있다.
중괄호 내에 선언되는 변수들은 모두 지역변수이다.
지역변수는 해당 선언문이 실행될 때 메모리 공간에 할당되었다가, 선언문이 존재하는 함수가 반환을 하면(종료를 하면) 메모리 공간에서 소멸된다.
매개변수도 지역변수이다.
지역변수를 가리켜 자동변수라고도 한다. 영역을 벗어나면 자동으로 소멸되기 때문이다.
전역변수는 프로그램 시작과 동시에 메모리 공간에 할당되어 종료 시까지 존재한다.
static 변수
	프로그램 시작과 동시에 할당 및 초기화가(전역변수) 되어서 프로그램이 종료될 때까지 메모리 공간에 남아있으나
	접근 범위를 해당 함수에 제한된다.(지역변수)
	선언이 반복되도 1회만 초기화됨.
register 변수
	register 선언을 추가해도 컴파일러가 합당하지 않다고 판단하면 레지스터에 할당되지 않는다. 반대로 선언을 안해도 컴파일러가 레지스터에 할당해야겠다고 판단하면 변수는 레지스터에 할당된다.
	전역변수에 register 선언을 추가할 수는 없다.
Recursive 함수
	Recursive 함수를 실행하는 중간에 다시 Recursive 함수가 호출 되면, Recursive 함수의 복사본을 하나 더 만들어서 복사본을 실행하게 된다.

11장
배열 크기를 초과하는 부분을 접근할 때, 컴파일러는 배열 접근에 있어서 유효성검사를 진행하지 않아서 컴파일 에러를 일으키지 않는다.
배열 초기화 시, {}를 사용해서 일부분만 초기화 할 경우 나머지는 0으로 채워진다. 
C언어에서 표현하는 모든 문자열의 끝에는 널 문자가 자동으로 삽입된다.
char arr1[]={'H', 'i', '~'}는 문자열이 아니다. 문자가 저장된 배열일뿐이다. 여기에 널문자가 추가가 된다면 그것은 문자열이다.

12장
포인터 변수를 한 줄에 여러 개를 선언 시, int *a, *b 이런식으로 선언 해야한다.

13장
배열이름은 상수 형태의 포인터이다. 배열의 이름을 가리켜 포인터 상수라고도 한다.
변수형태의 문자열 : 내용 변경 가능, 항상 이 문자열의 시작 주소를 저장
	char str1[] = "My String";
상수형태의 문자열 : 내용 변경 불가능, 다른 주소 저장 가능.
	char *str2= "Your String";
큰따옴표로 묶여서 표현되는 문자열은 그 형태에 상관없이 메모리 공간에 저장된 후 그 주소 값이 반환된다.
printf 도 사실상 문자열의 주소 값을 전달받는 함수인 것이다.

14장
함수 인자 전달할 때, 실제로 전달되는 것은 변수가 아닌 변수에 저장되어 있는 값이다.
매개변수 선언에서 int *param 과 int int param[]은 동일하다.
Call-by-value
	함수 호출 시 단순히 값을 전달하는 형태
Call-by-reference
	메모리에 접근에 사용되는 주소 값을 전달하는 형태의 함수 호출
const 위치에 따라서 상수화 되는 것이 다르다.
	맨 앞 : 포인터가 참조하는 값이 상수화
	이름 앞 : 포인터 값이 상수화

16장
2차원 이상의 배열을 다차원 배열이라 한다.
2차원 배열 선언법
	TYPE 이름 [세로길이][가로길이]
메모리의 주소 값은 1차원적 구조이다.

17장
이중 포인터와 포인터 배열의 관계
	int *ptrArr[] = ...
	int **dptr = ptrArr;
	위와 같이 대입이 가능한 이유는 두 변수 간 포인터 형이 일치함을 뜻한다.

18장
배열 이름을 대상으로 증가 및 감소 연산을 할 경우, 결과는 각 행의 첫 번째 요소의 주소 값이 된다.
때문에 2차원 배열을 이루는 요소의 자료형이 같더라도 배열의 가로길이가 다르면 포인터 연산의 결과는 달라진다.
배열 포인터 변수 : TYPE (*이름)[N]
	TYPE 형 변수를 가리키면서, 포인터 연산 시 sizeof(TYPE)*N 만큼 값이 증가/감소하는 포인터 변수
arr[2][1]=4;
	(*arr+2)[1]=4;
	*(arr[2]+1)=4; -> arr[2]를 A로 치환 -> A[1]=4 -> 배열이름은 포인터 -> *(A+1)=4 -> *(arr[2]+1);
	*(*(arr+2)+1)=4; -> 위에서 *(arr[2]+1)을 -> *(*(arr+2)+1)로 바꾼 것.

19장
함수 이름도 함수가 저장된 메모리 공간의 주소 값을 의미한다.
함수 이름도 상수이다.
함수 포인터 선언
	TYPE (*이름)(TYPE, ...);
	ex)
		void (*fptr)(int, int) = SimpleAdder;
		fptr(num1, num2);
void 포인터는 함수 주소 값도 담을 수 있다.
void 포인터 가지고는 아무런 포인터 연산 불가능하다. 값 변경이나 참조 불가능(가리키는 대상에 대한 어떠한 Type 정보가 없으니 당연한 것)

21장
스트림 : 한 방향으로 흐르는 데이터의 흐름
데이터 입력과 출력 : 프로그램의 흐름
입력 : 프로그램을 중심으로 프로그램 안으로 데이터가 흘러 들어오는 것이 입력
출력 : 프로그램 밖으로 데이터가 흘러 나가는 것이 출력
스트림은 운영체제에서 제공하는 소프트웨어적인 가상의 다리이다.
콘솔은일반적으로 키보드와 모니터를 의미한다.
콘솔 입출력을 위한 입력 스트림, 출력 스트림은 프로그램이 실행되면 자동으로 생성되고 프로그램이 종료되면 자동으로 소멸되는 스트림이다. 즉 이 둘은 기본적으로 표준 스트림이다.
putchar, fputc의 차이점은 fputc 함수는 문자를 전송할 스트림을 지정할 수 있다. 이 때 스트림을 stdout으로 지정하면 putchar 와 동일하다.
입력에서는 위와 동일한 getchar, fgetc 가 있다.
키보드 대상으로 하는 fgetc 함수와 getchar 함수의 EOF 반환하는 경우
	함수호출 실패
	Windows에서 CTRL + Z, Linux 에서 CTRL + D 키가 입력되는 경우
fputc, fgetc, putchar, getchar 모두 반환형이 int 형인 이유
	EOF형은 -1이다. char 형을 unsigned char 로 처리하는 컴파일러도 존재하기 때문이다.
문자 단위 입출력 함수의 존재 이유
	printf, scanf 함수 같이 화려한 기능을 제공하는 함수들은 메모리 공간도 크고 해야할 연산의 양도 많아서 속도가 느리다. 또한 별도의 서식지정을 해야해서 문장 구성도 번거롭기 때문에 단순히 문자 하나를 출력할 경우에 이 함수들을 만들어 놓은 것이다.
puts 함수는 출력의 대상이 stdout으로 결정되어 있다.
puts 함수 호출되면 자동개행, fputs는 아님.
fgets 는 \n 만날 때까지 문자열을 읽는데, \n을 문자열로 포함시킴.
표준 입출력함수(printf, scanf, fgetc, fputc, ...)를 통해 데이터를 입출력하는 경우 해당 데이터들은 운영체제가 제공하는 '메모리 버퍼'를 중간에 통과하게 된다. 여기서 메모리 버퍼는 데이터를 임시로 저장하는 메모리 공간이다.
데이터를 목적지로 바로 전송 안하고 중간에 입력, 출력 버퍼를 둬서 버퍼에 데이터를 저장하는 이유
	키보드, 모니터와 같은 외부 장치와의 데이터 입출력은 생각보다 시간이 걸리는 작업이라 중간에 메모리 버퍼를 둬서 데이터를 한데 묶어서 이동시키는 것이 보다 효율적이고 빠르기 때문이다.
출력 버퍼 비워짐 : 저장된 데이터가 목적지로 전송, 입력 버퍼 비워짐 : 데이터의 소멸을 의미한다.
strncpy는 딱 정해진 값만 복사하기에 널 문자를 신경 쓰지 않는다. 따라서 case 3 처럼 크기-1 까지만 복사하고 마지막에는 널문자를 넣어줘야한다.
strcat은 문자열을 서로 이어 붙이는 역할을 하는데 붙이는 시작 부분이 앞의 문자열의 널문자 부분이다.
strncpy와는 다르게 strncat은 자동으로 마지막에 널 문자를 넣어준다.
strcmp는 널문자도 비교 대상에 포함시킨다.
strcmp의 반환값은 P442 참조. 사전편찬 순서에 따라서 양수, 음수 값이 결정됨.

22장
구조체 변수 선언은 앞에다가 struct를 붙이면 됨.
구조체 변수 초기화를 할 때 배열 처럼 {}를 쓸 수 있다.
구조체 변수 초기화 시 문자열 저장을 위해 strcpy 함수를 호출하지 않아도 된다.
구조체 포인터 사용법
	포인터변수->멤버
	(*포인터변수).멤버
구조체 변수 멤버에 구조체 포인터가 있을 경우
	(구조체변수.포인터)->포인터의 멤버(소괄호 생략 가능)
구조체 변수의 주소 값은 구조체 변수의 첫 번째 멤버 변수의 주소 값과 동일하다.

23장
typedef로 정의되는 자료형의 이름은 대문자로 시작하는 것이 관례이다.
typedef로 struct 옆 구조체 이름을 생략할 경우 구조체 변수 선언 시, struct 구조체이름 변수이름 과 같이 선언하는 것은 불가능하다.
구조체를 정의하는 이유
	데이터 표현, 관리가 용이해진다.
구조체 변수 초기화하는 경우에도 초기화하지 않은 일부 멤버가 있으면 0 으로 초기화가 진행된다.
공용체는 구조체와는 달리 가장 큰 멤버 변수만 메모리에 할당되어서 이를 공유한다.
열거형은 변수에 저장이 가능한 정수 값들을 결정하겠다는 의미이다.
열거형에서 이름만 선언하고 값은 선언하지 않을 경우, 0부터 시작해서 1씩 증가하는 형태로 결정된다.
열거형은 구조체와 공용체의 정의 목적과는 다르다. 열거형의 유용함은 둘 이상의 연관이 있는 이름을 상수로 선언함으로써 프로그램의 가독성을 높이는데 있다.
enum {Do=1, Re=2, Mi=3, Fa=4, So=5, La=6, Ti=7}; 변수 선언이 목적이 아닌 상황에서 이렇게 자료형 이름을 생략하여 선언할 수도 있다.

24장
파일을 읽기 위해서는 기본적으로 스트림을 형성해야 데이터를 주고 받을 수 있다.
스트림 형성을 위한 함수가 fopen
스트림 소멸을 위한 함수가 fclose
fclose 함수로 개방되었던 파일을 닫아줘야 하는 이유
	운영체제가 할당한 자원의 반환
	버퍼링 되었던 데이터의 출력 -> 파일 스트림 경우에도 중간에 입력버퍼와 출력버퍼가 존재한다. -> 외부적인 요인으로 전원이 꺼지거나 하면 파일에 데이터가 저장되지 않는다. -> fclose 호출로 버퍼를 비우면 버퍼에 저장되어있던 데이터는 파일로 이동한다.
fflush에 관해서 말하면
	출력 버퍼를 비운다는 것은 출력 버퍼에 저장된 데이터를 목적지로 전송한다는 의미
	입력 버퍼를 비운다는 것은 입력 버퍼에 저장된 데이터를 소멸시킨다는 의미
	fflush는 출력 버퍼를 비우는 함수, fflush 함수는 입력 버퍼를 대상으로 호출할 수 없다.
위 내용은 파일 스트림에도 똑같이 적용된다.
파일 스트림의 입력 버퍼를 비우는 함수는 필요가 없다. 이유는 파일에 저장된 데이터는 원할 때 언제든지 읽을 수 있고(읽혀지면 입력버퍼에서 지워짐)그러한 상황이 특별히 존재하지 않는다.
스트림 형성 기준
	읽기? 쓰기?
	텍스트 데이터를 위한 것? 바이너리 데이터를 위한 것?
여기서 텍스트 바이너리를 구분짓는 방법
	텍스트 : 사람이 인식할 수 있는 문자를 담고있는 파일(도서 목록, 물품 가격)
	바이너리 : 그 이외에 컴퓨터가 인식할 수 있는 데이터를 담고있는 파일(영상파일, 음원파일)
\n은 C언어만의 약속이다. 그러나 운영체제는 이를 각자의 기준으로 개행을 다르게 정의한다. 그래서 변환이 필요한데 이때 파일을 텍스트 모드로 개방하면 자동으로 변환한다.
fopen 에서 개방 모드를 아무것도 정하지 않으면 파일은 텍스트 모드로 개방한다.
문자열이 파일에 저장될 때, 널 문자는 저장되지 않는다. 때문에 파일에서는 개행을 기준으로 문자열을 구분한다.
파일 입출력에서 구조체 변수를 통째로 읽을 수 있는 방법은 구조체 변수를 하나의 바이너리 데이터로 인식하는 것이다.
fseek 에서 매개변수 중 wherefrom 은 시작위치를 결정하는데, 이 때 SEEK_END가 전달되면 파일의 마지막 데이터가 아닌 파일의 끝을 표시하기 위해서 삽입되는 EOF를 의미한다.

25장
스택에는 지역변수뿐만이 아닌 매개변수가 할당된다.
프로그램의 시작은 실제로 main 함수 호출되기 이전에 데이터 영역이 먼저 초기화된다.
calloc은 malloc과 다른 점이 매개변수 수 차이가 있으며 초기화도 calloc은 0으로 malloc은 쓰레기값으로 초기화시킨다.
한번 할당된 메모리 공간은 그 크기를 확장할 수 없다. 이는 모든 영역의 메모리 공간에 해당하는 말이다. 그러나 그 영역이 힙이고 realloc을 사용한다면 가능하다.
25-2-1 못품

26장
컴파일 이전에 선행처리라는 과정을 거친다. 선행처리기를 거치면 파일은 그대로 소스파일이 나온다. 대부분 단순치환을 하는 경우이다.
#define 	PI 		3.141592
↑지시자  	↑매크로  ↑매크로 몸체(=대체 리스트)
PI와 같은 매크로를 가리켜 매크로 or 매크로 상수라 한다.
#define	SQUARE(X) X*X 는 매크로 함수(=함수와 유사한 매크로)라한다.
선행처리기에 의하여 변환되는 과정을 매크로 확장이라 한다.
매크로 함수를 정의할 때, 매크로 몸체 부분을 구성하는 X와같은 전달인자 하나하나에 괄호를 해야함은 물론이고, 반드시 전체를 괄호로 한번 더 묶어줘야한다. P562참조
매크로를 두 줄 이상 걸쳐서 정의할 시 문자를 사용해서 줄이 바뀌었음을 명시해야한다.
	#defien SQUARE(X) \
				((X) * (X))
함수를 매크로로 정의할 때 얻는 장점들
	일반 함수에 비해서 실행속도가 빠르다 -> 함수 호출 시 다음 사항들이 동반된다. 따라서 함수의 빈번한 호출은 실행속도의 저하로 이어진다. 반면 매크로 함수는 선행처리기에 의해서 매크로 함수 몸체 부분이 매크로 함수 호출 문장을 대신하기 때문에 밑에서 언급한 사항들을 동반하지 않는다.
											1. 호출된 함수를 위한 스택 메모리 할당
											2. 실행위치 이동과 매개변수로의 인자전달
											3. return 문에 의한 값의 반환
	자료형에 따라서 함수를 정의하지 않아도 된다. ->MacroFunction.c 를 참조하면 알 수 있듯이 전달인자에 상관없이 제대로 치환된다.
매크로 함수의 단점
	정의하기가 정말 까다롭다 ->매크로를 잘못 정의할 경우, 에러 메시지는 선행처리 이전의 소스파일을 기준이 아닌, 선행처리 이후의 소스파일을 기준으로 출력이 된다. 그래서 이해하기가 힘들다는 단점이 있다.
	디버깅하기 쉽지 않다.
이런 함수들을 매크로로 정의하자.
	작은 크기의 함수
	호출 횟수가 높은 함수.
#if~#endif에는 #if가 등장하면 반드시 #endif가 등장해야 한다. 조건에 따라서 지시자 사이에 존재하는 코드는 삽입되고 거짓이면 삭제된다.
#ifdef~#endif 는 매크로가 정의되었는지를 판단한다.
#ifndef~#endif 는 #ifdef와는 반대로 정의되지 않았는지 판단한다. 주로 헤더파일의 중복포함을 막기 위하여 사용한다.
문자열 안에서는 매크로의 매개변수 치환이 발생하지 않는다. 그러나 #연산자를 쓰면 가능하다.
char *str = "ABC" "DEF" 는 char *str = "ABCDEF" 와 같다.
매크로 ##연산자는 매크로 함수의 전달인자를 다른 대상과 이어줄 때 사용한다.

27장
extern 키워드는 컴파일러에게 어디에 선언되었는지를 알려주는 메시지일뿐 무언가를 선언하거나 할당하는 것이 아니다.
static를 선언하면 이 변수의 접근범위를 파일 내부로 제한한다는 의미이기도 하다.(함수, 변수 포함)
#include 지시자는 해당 파일의 내용을 단순히 포함시키는 용도로 사용된다.
매크로 명령문도 파일 단위로만 유효
컴파일러는 파일 단위로 컴파일을 진행하며 다른 파일 정보를 참조하여 컴파일을 진행하지 않는다.
헤더 파일이 중복삽입 자체는 문제가 되지 않는다. 그러나 구조체를 중복 정의하는 것은 문제가 된다.